# AVP规划算法和问题总结
该文档总结百度Apollo AVP2规划算法方案，和项目中遇到和解决的问题。

## AVP规划算法
规划算法分为巡航规划和泊车规划，其中巡航规划又分为巡航纵向规划和巡航横向规划。

### 巡航规划
巡航规划采用横纵向解耦的策略，横向规划输出一条安全的动力学可行的轨迹（位置，姿态，曲率），纵向规划在横向轨迹点的基础上增加速度信息，涉及纵向行车安全和体感等方面。
1. 横向规划：采用Apollo经典Lattice算法，即撒点采样+评价筛选，直观简洁，久经验证  
主要算法是单层lattice，在frenet坐标系通过撒点采样和五次多项式参数化得到一组可行解集，利用轨迹评价函数得到最优的备选轨迹。Apollo规划的前提是必须有光滑的指引线，指引线的获取等内容暂时未涉及，可以参考下面链接中的问答：
[Apollo规划算法问答](https://zhuanlan.zhihu.com/p/69878689).  
巡航阶段横向规划的框图可以参考下面图片，输入是障碍物信息/规划起点坐标/车辆状态信息，输出是离散化轨迹
![总体框图](../img/avp_cruise_lateral_planning.png)
上述子模块之一采样边界确定的大体流程如下，输入是障碍物信息/示教轨迹/规划起点，输出是离散边界条件
![采样边界](../img/sampling_boundary.png)
上述子模块之二横向采样大体流程如下，输入是边界信息，输出是多项式参数的轨迹集
![quinticPoly](../img/quinticPolynomial.png)  
Lattice Planner输出的轨迹是一条光滑无碰撞满足车辆运动学约束和速度约束的平稳安全的局部轨迹。Lattice Planner要注意是局部轨迹规划器，全局轨迹规划  

2. 纵向规划：新方案复用ANP2高斯伪谱，但是老方案还没有加进去   
纵向规划的目的是求出规划轨迹上的速度。  
    2.1. 纵向安全急刹距离 Ssafe = 纵向急刹距离Sstop + 纵向安全冗余距离Sboundary + EM不确定度EMerror; 其中纵向安全冗余距离根据不同类型障碍物和车辆当前巡航状态进行设计，分为巡航状态和绕障状态，分别对行人（如0.8m）/车辆（如0.6m）和其他障碍物（如0.5m）有不同的冗余距离设定；EM不确定度由EM提供；纵向急刹距离由ADAS软件延时距离（取上限）+抱死滑行距离计算得来。  
    2.2. 纵向缓刹区域：阿克曼预测缓刹区域，基于阿克曼运动学模型和车辆周边不同距离，划定不同的区域。图片中（照片）紫蓝区域参与纵向ACC障碍物筛选和轨迹截断。  
    2.3. 纵向跟车方案：输入横向规划结果/当前车速/障碍物信息->根据障碍物位置计算巡航终点->根据动态/静态障碍物计算目标车速->计算目标加速度->计算安全加速度->融合两个加速度merge()->更新最终速度计算update_self_speed()。 ACC速度规划主要是遍历每个轨迹点计算速度和加速度，每个点根据剩余距离和道路曲率，结合lookup_table()计算目标速度。merge()是通过定义ratio来实现的。动态障碍物ACC速度规划简化版如下，根据轨迹点到障碍物的距离$\Delta S_{index}$，使用分段公式计算该轨迹点的最大允许速度$v_{allow}$，小于安全距离为0/安全距离和跟随距离之间就取$min(v_{limit}, v_{obs})$，如果大于跟随距离就直接根据牛顿运动学公式计算速度；再根据轨迹点的曲率进行限速$v_{limit}$；然后取$min(v_{allow}, v_{limit})$。
    2.4. 阿克曼预测缓刹：目的是通过规划路径和车辆状态预测本车接下来将要行驶的路径，作为障碍物筛选的路径。具体流程如下图：  
    ![Ackermann](../img/Ackermann_trajectory.png)   
    2.5. 控制模型预瞄点计算：首先计算最近规划点，通过计算车辆位置和规划点之间的距离得到最近规划点；然后计算车辆相对于最近规划点的$\delta s$；然后匹配最近规划点前方$(preview_distance + \delta s)$的规划点，不存在这样的点要进行插值。  
    2.6. 障碍物截断：根据障碍物和车辆轨迹遍历所有的碰撞点，计算sl坐标，得到碰撞点中s最小的点输出给acc，acc中减去预留的安全距离作为路径截断的长度，根据该长度截断路径。

### 泊车规划
泊车规划采用基于双匀速曲线的几何规划算法，利用有限状态机实现揉库动作切换，简单高效省算力；在中高算力平台上可以采用搜索+优化的规控算法，更灵活智能和鲁棒。  
泊车规划的具体实现流程：
1. 环境信息预处理 collect_upstream_data(): 对泊入泊出用到的不同信息处理，包括出入库模式/车位类型/出入库方向/道路中心线和泊出终点等。
2. 规划状态决策 DataUpdate(&_parking_data): 该函数会根据车辆当前所处的状态跳转到对应的跳转函数，用于判断是否更新当前状态。
3. 规划数据收集封装 collect_data(in_parking_data): 把规划用到的数据收集保存，减少频繁的来回调用。
4. 理想轨迹生成 generate_trajectory(): 根据当前车辆状态，调用当前状态下的路径生成方式，生成规划用到的理想轨迹。
5. 根据车速延长轨迹 lengthen_trajectory(): 理想轨迹生成只考虑到实时环境信息，没有考虑到前后帧变化，为避免急刹需要根据速度延长轨迹。
6. 障碍物处理 obs_deal(in_parking_data): 根据理想轨迹筛选最近的点障碍物，根据障碍物类型进行限速和障碍物刹停时的状态跳转条件判断。
7. 障碍物决策 obs_to_trajectory(): 根据最近的点障碍物确定轨迹状态，包括轨迹截断，障碍物刹停；若无障碍物影响则直接使用理想轨迹。
8. 轨迹处理 check_traj_nan(): 轨迹异常检查，判断轨迹是否存在必要字段缺失，或者重复轨迹点（造成除零）等异常。  

泊车规划采用的是基于几何的路径规划方式，路径规划方式主要是圆弧和直线。对于圆弧轨迹需要计算出当前状态下车辆的转弯半径和转向角度，对于直线轨迹要计算出轨迹长度。泊车规划都是根据当前位置实时规划（10Hz），包括直线规划器/圆弧规划器/速度规划。当前规划考虑如下几种状态：   
1. 车尾垂直库和斜库出入库: 直线行驶straight_path_producer.cpp + 圆弧规划rotate_path_producer.cpp
2. 平行库出入库: 直线行驶straight_path_producer_paral.cpp + 圆弧规划rotate_path_producer_paral.cpp
3. 车头斜库出入库: 直线行驶straight_path_producer_heading.cpp + 圆弧规划rotate_path_producer_heading.cpp   

垂直或斜车位车尾泊入整体流程见下图：
平行泊入整体流程见下图：
垂直泊出整体流程见下图：
泊车算法关键几何关系见下图：


## AVP项目问题总结

### 海马AVP项目问题

### 日产AVP项目问题